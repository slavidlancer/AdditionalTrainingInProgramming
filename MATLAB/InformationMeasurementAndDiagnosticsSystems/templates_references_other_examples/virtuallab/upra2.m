function slide=upr2
% This is a slideshow file for use with playshow.m and makeshow.m
% To see it run, type 'playshow upr2', 

% Copyright (c) 1984-98 by The MathWorks, Inc.
if nargout<1,
  playshow upr2
else
  %========== Slide 1 ==========

  slide(1).code={
   'DATA = imread(''upra0.bmp'');',
   'imshow(DATA);',
   'imwrite(DATA, ''myfile.bmp'');',
   '' };
slide(1).text={
   '',
   '',
   '                                   Лабораторно упражнение №2',
   '',
   '',
   '                                             ПЕРЦЕПТРОН'};
%========== Slide 2 ==========

  slide(2).code={
   'DATA = imread(''upr251.bmp'');',
   'imshow(DATA);',
   'imwrite(DATA, ''myfile.bmp'');',
   '',
   '' };
  slide(2).text={
   'Теоретична част:',
   '',
   '   Перцептронът представлява нелинеен неврон. При него се използва твърдо ограничена /hard limiter/ активационна функция Ф(v), която дава изход 0 или 1. Както беше обяснено в упр.1 с х се отбелязват входните на входните елементи, с w синаптичните теглови коефициенти и с b се означава отместването.',
   '   Входът на невронната мрежа v се дава с уравнение (1), където отклонението b се третира като теглови коефициент wo подавано към специален входен елемент хо, който винаги е активен т.е. хо=1.'};

  %========== Slide 3 ==========

  slide(3).code={
   'DATA = imread(''upr252.bmp'');',
   'imshow(DATA);',
   'imwrite(DATA, ''myfile.bmp'');',
   '',
   '' };

  slide(3).text={
   '   Изхода на мрежата y се дава с уравнение (2), където Q е прагът на активация на неврона.',
   '   Един перцептрон може да раздели дадено пространствено множество на две групи според функцията на принадлежност на елементите изобразено на фиг.1.',
   '   Два перцептрона могат да разделят решенията на дадено пространството на четири зони с три групи елементи или на две групи елементи всяка т които разположена в два подучастъка, изобразено съответно на фиг.2 и фиг.3.'};

  %========== Slide 4 ==========

  slide(4).code={
   'DATA = imread(''upr253.bmp'');',
   'imshow(DATA);',
   'imwrite(DATA, ''myfile.bmp'');',
   '',
   '' };

  slide(4).text={
   '   Границата на решенията за дадена мрежа се определя от входа, който дава изход нула на изхода на мрежата и се представят с уравнение (3).',
   '   Алгоритъма за обучение на перцептрона е следния:',
   '      -Задаваме w(0)=0 за всеки елемент на обучаващата извадка х(t) за t=1,2,3….',
   '     -Изчисляваме  e=d-Ф(wTx(t)), където е е грешката, d e целевата стойност  и w е вектора на тегловите коефициенти.',
   '     -Прилагаме правилото за обучение на перцептрона w=w+ex(t) за да променим стойностите на тегловните коефициенти и чрез b=b+e да обновим стойностите на отместването',
   '',
   ''};

  %========== Slide 5 ==========

  slide(5).code={
   'DATA = imread(''upra0.bmp'');',
   'imshow(DATA);',
   'imwrite(DATA, ''myfile.bmp'');',
   '',
   '' };

  slide(5).text={
   '       -Процедурата се прекратява ако не се получат обновления на тегловите коефициенти  на тестовата извадка за следващите итерации или ако не се удовлетвори някой предварително зададен критерии за край на алгоритъма.',
   '   При използване на повече от един перцептрони формулите използвани в алгоритъма се използват в матричен вид'};


  %========== Slide 6 ==========

  slide(6).code={
   '' };
  slide(6).text={
     'Цел на лаботарорното упражнение:',
     '',
             ' При зададени двумерни входни елементи, със съответната им калсова принадлежност да се установи дали е възмжно да бъдат линейно разделени входните елементи на два класа, чрез използване на единичен перцептрон.'};

  %========== Slide 7 ==========

  slide(7).code={
   'P = [ -0.5 -0.5 +0.3 -0.1 +0.5;  -0.5 +0.5 -0.5 +1.0 -1];',
   'T = [1 0 0 0 1];',
   ' plotpv(P,T);',
   '' };
  slide(7).text={
   'Начин на провеждане на лабораторното упражнение:',
   '',
   '   1. Задаваме колона от двумерни входни вектора'
   '        %P = [ -0.5 -0.5 +0.3 -0.1 +0.5;  -0.5 +0.5 -0.5 +1.0 -1]';'Задаваме целите на входните вектори';
   '        %T = [1 0 0 0 1]'; 'Изчератваме векрорите';
   '        %plotpv(P,T)';
};

  %========== Slide 8 ==========

  slide(8).code={
   'net=newp([-1 1;-1 1],1);',
   ' plotpv(P,T);',
   'linehandle=plotpc(net.IW{1},net.b{1});',
   'plotpv(P,T);',
   '    linehandle=plotpc(net.IW{1},net.b{1});',
   '   E=1;',
   '   net=init(net);',
   '   linehandle=plotpc(net.IW{1},net.b{1});',
   '   while (sse(E))',
   '   [net,Y,E]=adapt(net,P,T);',
   '      linehandle=plotpc(net.IW{1},net.b{1},linehandle);',
   '      drawnow;',
   '  end;',
   '',
   '' };
  slide(8).text={
     '  2. Перцептрона трябва да раздели входните вектори на два типа класово отделени вектора. тези неврони могат да разделят входните елементи само с права линия на два калса.'
     '%net=newp([-1 1;-1 1],1)';
     '%plotpv(P,T)';
     '%linehandle=plotpc(net.IW{1},net.b{1})';
     '%plotpv(P,T)';'Виждаме началния опит за дефениране на перцептрона: ';
     '%linehandle=plotpc(net.IW{1},net.b{1})';
       };
  %========== Slide 9 ==========

   slide(9).text={
     'Задаваме началните тегла да са равни на нула';
     '%E=1';
     '%net=init(net)';
     '%linehandle=plotpc(net.IW{1},net.b{1})';
     '%while (sse(E))';
     '%[net,Y,E]=adapt(net,P,T)';
     '%linehandle=plotpc(net.IW{1},net.b{1},linehandle)';
     '%drawnow';
     '%end';
  };

  %========== Slide 10 ==========

  slide(10).code={
   'p=[0.7; 1.2];',
   '   a = sim(net,p);',
   '   plotpv(p,a);',
   '  hold on;',
   '   plotpv(P,T);',
   '   plotpc(net.IW{1},net.b{1});',
   '   hold off;',
   '      sse(E)',
   ' P = [ -0.5 -0.5 +0.3 -0.1 -0.8;  -0.5 +0.5 -0.5 +1.0 +0.0 ];',
   'T = [1 1 0 0 0];',
   'plotpv(P,T);',
   'net = newp([-40 1;-1 50],1);',
   'hold on',
   'plotpv(P,T);',
   'linehandle=plotpc(net.IW{1},net.b{1});',
   'net.adaptParam.passes = 3;',
   'linehandle=plotpc(net.IW{1},net.b{1});',
   'for a = 1:25',
   ' [net,Y,E] = adapt(net,P,T);',
   ' linehandle = plotpc(net.IW{1},net.b{1},linehandle);  drawnow;',
   'end;',
   'sse(E)',
   '' };
  slide(10).text={
     '  3. Получаваме множество линейно разделими 0 и 1, а за линейно неразделимите множества се получава :'
         '%P = [ -0.5 -0.5 +0.3 -0.1 -0.8;  -0.5 +0.5 -0.5 +1.0 +0.0 ];',
         '%T = [1 1 0 0 0]';
         '%plotpv(P,T)';
         '%net = newp([-40 1;-1 50],1)';
         '%hold on';
         '%plotpv(P,T)';
         '%linehandle=plotpc(net.IW{1},net.b{1})';
      };
      %========== Slide 11 ==========

   slide(11).text={
         'net.adaptParam.passes = 3';
         'linehandle=plotpc(net.IW{1},net.b{1})';
         'for a = 1:25';
         '[net,Y,E] = adapt(net,P,T)';
         'linehandle = plotpc(net.IW{1},net.b{1},linehandle)';  
         'drawnow';
         'end;';
         'sse(E)';
      };

end