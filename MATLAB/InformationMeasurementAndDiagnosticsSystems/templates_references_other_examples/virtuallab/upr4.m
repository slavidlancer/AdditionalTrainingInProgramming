function slide=upr4
% This is a slideshow file for use with playshow.m and makeshow.m
% To see it run, type 'playshow upr4', 

% Copyright (c) 1984-98 by The MathWorks, Inc.
if nargout<1,
  playshow upr4
else
   


  %========== Slide 1 ==========

  slide(1).code={
   'DATA = imread(''upra40.bmp'');',
   'imshow(DATA);',
   'imwrite(DATA, ''myfile.bmp'');',
   '',
   '' };
slide(1).text={
   '',
            '                                      Лабораторно упражнение № 4',
     '',
     '',
     '',
   '              SELF OGRANISING MAPS .',
   
                                          };

%========== Slide 2 ==========

  slide(2).code={
   'DATA = imread(''upra40.bmp'');',
   'imshow(DATA);',
   'imwrite(DATA, ''myfile.bmp'');',
   '',
   '' };
slide(2).text={
   'Теоретична част:',
   '',
   '   Една от най-интерестните области при невронните мрежи е самоорганизирането. Такива мрежи могат да разпознават връзки между различни входни данни и да променят изхода си в зависимост от това. Невроните, които се състезават за изходен сигнал се научават да разпознават група от входни вектори. Характерно е, че близки неврони отговарят на подобни данни по сходен начин. Невроните в състезателния слой разпознават често представяни входни данни.',
   '   За обучение на мрежи със състезателен слой се използва правилото на'
   }
   %========== Slide 3 ==========

  slide(3).code={
   'DATA = imread(''upr51.bmp'');',
   'imshow(DATA);',
   'imwrite(DATA, ''myfile.bmp'');',
   '',
   '' };
  slide(3).text={
     'Aко неврон с индекс i печели, то неговите коефициенти се променят по формула (1).',
     '   Правилото позволява теглата на даден неврон да научат входния вектор, което е полезно при задачи за разпознаване. Теглата на неврона, които са най-близо до входния вектор се променят, така че да се доближат повече. В резултат слечелилият неврон, при повторно обучение, е по-вероятно да спечели отново, когато се представи подобен входен вектор и по-малко вероятно е да спечели когато когато се представи много различен входен вектор. Колкото повече обучаващи вектора се представят на мрежата, толкова по-барзо отделните неврони се научават да разпознават групи '
     ''};
  %========== Slide 4 ==========

  slide(4).code={
   'DATA = imread(''upra40.bmp'');',
   'imshow(DATA);',
   'imwrite(DATA, ''myfile.bmp'');',
   '',
   '' };
slide(4).text={
   'входни вектори.',
   'Ако има достатъчен брой неврони в състезателния слой, всеки се научава да разпознава определена група вектори, което е и целта на задачите за класификация.'
    }

%========== Slide 5 ==========

  slide(5).code={
   'DATA = imread(''upra40.bmp'');',
   'imshow(DATA);',
   'imwrite(DATA, ''myfile.bmp'');',
   '',
   '' };

  slide(5).text={
     
   'Цел на лабораторното упражнение:',
   '',
   '',
   '   Разположете 4000 (random) входни данни разпределени в пространството от 0 до 10, по Х и от 0 до 10 по Y и се опитайте да ги гропирате в 15 клъстера. След групирането по клъстери подайте на входа на мрежата елемент със стойност х,у [-5.3,+8.1] и пределете към кой клас клъстер принадлежи.'
   ''};

  %========== Slide 6 ==========

  slide(6).code={
   'X = [0 10; 0 10];',
   'clusters = 20;',
   'points = 15;',
   'std_dev = 0.05;',
   'P = nngenc(X,clusters,points,std_dev);',
   'plot(P(1,:),P(2,:),''+r'');',
   'title(''Imput vectors'');',
   'xlabel(''p(1)'');',
   'ylabel(''p(2)'');',
   '' };
  slide(6).text={
        'Начин на провеждане на лабораторното упражнение:',
   '',
   
   
   '  1. Създаване на пространство където ще се разполагат клъстерите.',
   '%X = [0 10; 0 10]';'Задаване на броя на клъстерите';
   '%clusters = 20';'Задаване на броя точки, които съставляват един клъстер.'
   '%points = 15';
   'Задаване на максималното отклонение на точките за всеки клъстер';
   '%std_dev = 0.05';
};
%========== Slide 7 ==========
slide(7).text={
   'Създаване на група произволно генерирани, но групирани на клъстери експериментални точки';
   '%P = nngenc(X,clusters,points,std_dev)';
   '%plot(P(1,:),P(2,:),''+r'')';
   '%title(''Imput vectors'')'; 
   '%xlabel(''p(1)'')';
      };
  %========== Slide 8 ==========

  slide(8).code={
   '',
   'net=newc([0 10;0 10],20,.01);',
     '   net=init(net);',
      '   w=net.IW{1};',
   '   hold on',
   '   plot(w(:,1),w(:,2),''ob'');,',
   'net.trainParam.epochs=200;',
   'net=train(net,P);',
   'w=net.IW{1};',
   'hold on',
   'plot(P(1,:),P(2,:),''+r'')',
   'hold on',
   'plot(w(:,1),w(:,2),''ob'');',
   'vhod = [2.5; 2.8];',
   'a=sim(net,vhod);',
   'output=evalc(''a'');',
   '' };
slide(8).text={
   '2. Изчертаване на входните данни.';
      'Създаване на невронна мрежа базирана на съревнованието-чрез използване на команда newc. Елементната матрица newc(Kх2) е матрица, в която се задават максималните и минималните стойности на К входни елемента, броя на невроните и скоростта на обучение.';
   '%net=newc([0 10;0 10],20,.01);';
   '%net=init(net);';

                 };
  end